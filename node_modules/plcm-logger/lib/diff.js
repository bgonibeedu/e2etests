//   © , Inc. 2012-2015. All Rights Reserved

'use strict';
// deep-diff doesn't track array movements, rolling out our own diff
// Use amdefine so that this can be used in both node/requirejs context. Browserify didn't work on the first attempt.
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}

define(['lodash'], function (_) {
        var ansicodes = {
            'reset': '\u001b[0m',
            'bold': '\u001b[1m',
            'italic': '\u001b[3m',
            'underline': '\u001b[4m',
            'blink': '\u001b[5m',
            'black': '\u001b[30m',
            'red': '\u001b[31m',
            'green': '\u001b[32m',
            'yellow': '\u001b[33m',
            'blue': '\u001b[34m',
            'magenta': '\u001b[35m',
            'cyan': '\u001b[36m',
            'white': '\u001b[37m'
        };
        var ADDED_CSS = 'background: white; color: darkgreen;';
        var REMOVED_CSS = 'background: white; color: darkred;';
        var PATH_CSS = 'background: white; color: indigo;';
        var inBrowser = typeof window !== 'undefined';


        /**
         *
         * @param left
         * @param right
         * @param path
         * @returns {Array} Array of diffs similar to what we get from deep-diff
         */
        function diff(left, right, path) {
            var changes = [];
            path = path || "";
            if (_.isEmpty(left) && _.isEmpty(right)) {
                return changes;
            } else if (!_.isEmpty(left) && _.isEmpty(right)) {
                changes.push({
                    kind : 'D',
                    lhs: left,
                    path: path
                });
            } else if (_.isEmpty(left) && !_.isEmpty(right)) {
                changes.push({
                    kind : 'N',
                    rhs: right,
                    path: path
                });
            } else if (!_.isObject(left) && !_.isObject(right)) {
                if (!_.isEqual(left, right)) {
                    changes.push({
                        kind: 'E',
                        path: path,
                        lhs: left,
                        rhs: right
                    });
                }
            } else {
                if (_.isArray(left) && _.isArray(right)) {
                    right.forEach(function (elem) {
                        if ((_.isObject(elem) && !_.find(left, elem)) ||
                            (!_.isObject(elem) && _.indexOf(left, elem) === -1)) {
                            changes.push({
                                kind : 'N',
                                rhs: elem,
                                path: path
                            });
                        }
                    });
                    left.forEach(function (elem) {
                        if ((_.isObject(elem) && !_.find(right, elem)) ||
                            (!_.isObject(elem) && _.indexOf(right, elem) === -1)) {
                            changes.push({
                                kind : 'D',
                                lhs: elem,
                                path: path
                            });
                        }
                    });
                } else {
                    var keys = _.union(_.keys(left), _.keys(right));
                    keys.map(function(key) {
                        changes = changes.concat(diff(left[key], right[key], path + ":" + key));
                    });
                }
            }
            return changes;
        }

        var changeNodeStr = function (change) {
            var message = '';
            if (change.path) {
                message += ansicodes.white + change.path + '\n';
            }
            switch (change.kind) {
                case 'E':
                    message += ansicodes.red + logger.DEL + ' ' + JSON.stringify(change.lhs) + '\t' +
                        ansicodes.green + logger.ADD + ' ' + JSON.stringify(change.rhs);
                    break;
                case 'N':
                    message += ansicodes.green + logger.ADD + ' ' + JSON.stringify(change.rhs);
                    break;
                case 'D':
                    message += ansicodes.red + logger.DEL + ' ' + JSON.stringify(change.lhs);
                    break;
                case 'A':
                    message += changeNodeStr(change.item);
                    break;
                default:
                    break;
            }
            return message;
        };

        var changeBrowserLog = function (change) {
            change.path = change.path || "";
            switch (change.kind) {
                case 'E':
                    console.log('%c %s %c --- %s %c +++ %s', PATH_CSS, change.path, REMOVED_CSS, change.lhs, ADDED_CSS, change.rhs);
                    break;
                case 'N':
                    console.log('%c %s %c +++ ', PATH_CSS, change.path, ADDED_CSS, change.rhs);
                    break;
                case 'D':
                    console.log('%c %s %c --- ', PATH_CSS, change.path, REMOVED_CSS, change.lhs);
                    break;
                case 'A':
                    changeBrowserLog(change.item);
                    break;
                default:
                    break;
            }
        };

        /**
         * Log the list of changes
         * @param changes [object] array of changes
         */
        function log(changes) {
            if (inBrowser) {
                // TODO: try logger for client too, start with console
                changes.map(function(change) {
                    changeBrowserLog(change);
                });
            } else {
                logger.debug('\n' + changes.map(function (change) {
                        return changeNodeStr(change);
                    }).join('\n'));
            }
        }

        return {
            diff: diff,
            log: log
        };
    }
);

